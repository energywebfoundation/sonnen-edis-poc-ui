"use strict";
// Copyright 2018 Energy Web Foundation
// This file is part of the Origin Application brought to you by the Energy Web Foundation,
// a global non-profit organization focused on accelerating blockchain technology across the energy sector,
// incorporated in Zug, Switzerland.
//
// The Origin Application is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
// This is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY and without an implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details, at <http://www.gnu.org/licenses/>.
//
// @authors: slock.it GmbH; Martin Kuechler, martin.kuchler@slock.it; Heiko Burkhardt, heiko.burkhardt@slock.it;
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const chai_1 = require("chai");
const fs = __importStar(require("fs"));
require("mocha");
const ew_user_registry_contracts_1 = require("ew-user-registry-contracts");
const ew_asset_registry_contracts_1 = require("ew-asset-registry-contracts");
const ew_origin_contracts_1 = require("ew-origin-contracts");
const Certificate = __importStar(require(".."));
const Logger_1 = require("../blockchain-facade/Logger");
const web3_1 = __importDefault(require("web3"));
const ew_market_contracts_1 = require("ew-market-contracts");
describe('CertificateLogic-Facade', () => {
    let userLogic;
    let certificateLogic;
    let assetRegistry;
    let assetRegistryContract;
    let originRegistryContract;
    let userRegistryContract;
    let erc20TestToken;
    let testReceiver;
    const configFile = JSON.parse(fs.readFileSync(process.cwd() + '/connection-config.json', 'utf8'));
    const web3 = new web3_1.default(configFile.develop.web3);
    const privateKeyDeployment = configFile.develop.deployKey.startsWith('0x') ?
        configFile.develop.deployKey : '0x' + configFile.develop.deployKey;
    const accountDeployment = web3.eth.accounts.privateKeyToAccount(privateKeyDeployment).address;
    const assetOwnerPK = '0xc118b0425221384fe0cbbd093b2a81b1b65d0330810e0792c7059e518cea5383';
    const accountAssetOwner = web3.eth.accounts.privateKeyToAccount(assetOwnerPK).address;
    const traderPK = '0x2dc5120c26df339dbd9861a0f39a79d87e0638d30fdedc938861beac77bbd3f5';
    const accountTrader = web3.eth.accounts.privateKeyToAccount(traderPK).address;
    const assetSmartmeterPK = '0x2dc5120c26df339dbd9861a0f39a79d87e0638d30fdedc938861beac77bbd3f5';
    const assetSmartmeter = web3.eth.accounts.privateKeyToAccount(assetSmartmeterPK).address;
    const matcherPK = '0xd9d5e7a2ebebbad1eb22a63baa739a6c6a6f15d07fcc990ea4dea5c64022a87a';
    const matcherAccount = web3.eth.accounts.privateKeyToAccount(matcherPK).address;
    const approvedPK = '0x7da67da863672d4cc2984e93ce28d98b0d782d8caa43cd1c977b919c0209541b';
    const approvedAccount = web3.eth.accounts.privateKeyToAccount(approvedPK).address;
    let conf;
    let marketContracts;
    let marketLogic;
    let marketLookup;
    let blockceationTime;
    it('should deploy the contracts', () => __awaiter(this, void 0, void 0, function* () {
        const userContracts = yield ew_user_registry_contracts_1.migrateUserRegistryContracts(web3, privateKeyDeployment);
        userLogic = new ew_user_registry_contracts_1.UserLogic(web3, userContracts.UserLogic);
        yield userLogic.setUser(accountDeployment, 'admin', { privateKey: privateKeyDeployment });
        yield userLogic.setRoles(accountDeployment, 3, { privateKey: privateKeyDeployment });
        const userContractLookupAddr = userContracts.UserContractLookup;
        userRegistryContract = new ew_user_registry_contracts_1.UserContractLookup(web3, userContractLookupAddr);
        const assetContracts = yield ew_asset_registry_contracts_1.migrateSonnenAssetRegistryContracts(web3, userContractLookupAddr, privateKeyDeployment);
        const assetRegistryLookupAddr = assetContracts.AssetContractLookup;
        const assetProducingAddr = assetContracts.AssetProducingRegistryLogic;
        const originContracts = yield ew_origin_contracts_1.migrateSonnenContracts(web3, assetRegistryLookupAddr, privateKeyDeployment);
        assetRegistryContract = new ew_asset_registry_contracts_1.AssetContractLookup(web3, assetRegistryLookupAddr);
        assetRegistry = new ew_asset_registry_contracts_1.SonnenProducingAssetLogic(web3, assetProducingAddr);
        marketContracts = yield ew_market_contracts_1.migrateMarketRegistryContracts(web3, assetRegistryLookupAddr, privateKeyDeployment);
        marketLogic = new ew_market_contracts_1.MarketLogic(web3, marketContracts.MarketLogic);
        marketLookup = new ew_market_contracts_1.MarketContractLookup(web3, marketContracts.MarketContractLookup);
        assetRegistryContract = new ew_asset_registry_contracts_1.AssetContractLookup(web3, assetRegistryLookupAddr);
        assetRegistry = new ew_asset_registry_contracts_1.SonnenProducingAssetLogic(web3, assetProducingAddr);
        Object.keys(originContracts).forEach((key) => __awaiter(this, void 0, void 0, function* () {
            if (key.includes('OriginContractLookup')) {
                originRegistryContract = new ew_origin_contracts_1.OriginContractLookup(web3, originContracts[key]);
            }
            if (key.includes('SonnenLogic')) {
                certificateLogic = new ew_origin_contracts_1.EnergyLogic(web3, originContracts[key]);
            }
        }));
        conf = {
            blockchainProperties: {
                activeUser: {
                    address: accountDeployment, privateKey: privateKeyDeployment,
                },
                producingAssetLogicInstance: assetRegistry,
                userLogicInstance: userLogic,
                certificateLogicInstance: certificateLogic,
                web3,
            },
            offChainDataSource: {
                baseUrl: 'http://localhost:3030',
            },
            logger: Logger_1.logger,
        };
    }));
    it('should return correct balances', () => __awaiter(this, void 0, void 0, function* () {
        chai_1.assert.equal(yield Certificate.Certificate.getCertificateListLength(conf), 0);
        chai_1.assert.equal(yield Certificate.TradableEntity.getBalance(accountAssetOwner, conf), 0);
        chai_1.assert.equal(yield Certificate.TradableEntity.getBalance(accountTrader, conf), 0);
    }));
    it('should onboard tests-users', () => __awaiter(this, void 0, void 0, function* () {
        yield userLogic.setUser(accountAssetOwner, 'assetOwner', { privateKey: privateKeyDeployment });
        yield userLogic.setUser(accountTrader, 'trader', { privateKey: privateKeyDeployment });
        yield userLogic.setRoles(accountTrader, 24, { privateKey: privateKeyDeployment });
        yield userLogic.setRoles(accountAssetOwner, 24, { privateKey: privateKeyDeployment });
    }));
    it('should onboard an asset', () => __awaiter(this, void 0, void 0, function* () {
        yield assetRegistry.createSonnenAsset(assetSmartmeter, accountAssetOwner, true, ['0x1000000000000000000000000000000000000005'], 'propertiesDocumentHash', 'url', 2, marketLookup.web3Contract._address, {
            privateKey: privateKeyDeployment,
        });
    }));
    it('should set MarketLogicAddress', () => __awaiter(this, void 0, void 0, function* () {
        yield assetRegistry.setMarketLookupContract(0, originRegistryContract.web3Contract._address, { privateKey: assetOwnerPK });
        chai_1.assert.equal(yield assetRegistry.getMarketLookupContract(0), originRegistryContract.web3Contract._address);
    }));
    it('should create a demand', () => __awaiter(this, void 0, void 0, function* () {
        yield marketLogic.createDemand('Saxonia', Date.now(), Date.now() + 1000, 1000, { privateKey: traderPK });
        console.log(yield marketLogic.getDemand(0));
    }));
    it('should create a supply', () => __awaiter(this, void 0, void 0, function* () {
        yield marketLogic.createSupply([0], 'Saxonia', Date.now(), Date.now() + 1000, 1000, 100, 10, { privateKey: traderPK });
    }));
    it('should create an agreement', () => __awaiter(this, void 0, void 0, function* () {
        yield marketLogic.createAgreement(0, [0], { privateKey: traderPK });
    }));
    let dateTimeFrom = Date.now() - 1000;
    let dateTimeTo = Date.now();
    it('should log energy', () => __awaiter(this, void 0, void 0, function* () {
        const tx = yield assetRegistry.saveSonnenSmartMeterRead(0, 500, 'lastSmartMeterReadFileHash', dateTimeFrom, dateTimeTo, 10, 10, 'url', { privateKey: assetSmartmeterPK });
        const event = (yield assetRegistry.getAllLogNewMeterReadEvents({ fromBlock: tx.blockNumber, toBlock: tx.blockNumber }))[0];
        chai_1.assert.equal(event.event, 'LogNewMeterRead');
        chai_1.assert.deepEqual(event.returnValues, {
            0: '0',
            1: '0',
            2: '500',
            _assetId: '0',
            _oldMeterRead: '0',
            _newMeterRead: '500',
        });
        console.log(tx);
        console.log(yield assetRegistry.getSonnenAssetById(0));
        const cert = yield (new Certificate.Certificate.Entity('0', conf).sync());
        console.log(cert);
        delete cert.configuration;
        delete cert.proofs;
        chai_1.assert.deepEqual(cert, {
            id: '0',
            initialized: true,
            assetId: '0',
            owner: '0xaf9DdE98b6aeB2225bf87C2cB91c58833fbab2Ab',
            powerInW: '500',
            acceptedToken: '0x0000000000000000000000000000000000000000',
            onCHainDirectPurchasePrice: '0',
            escrow: [],
            approvedAddress: '0x0000000000000000000000000000000000000000',
            activationId: '0',
            dateTimeFrom: '' + dateTimeFrom,
            dateTimeTo: '' + dateTimeTo,
            energyAmount: '500',
            averagePower: '10',
            baselinePower: '10',
            powerProfileURL: 'url',
            powerProfileHash: 'lastSmartMeterReadFileHash',
            reportConfirmed: false,
        });
    }));
    it('should create a demand', () => __awaiter(this, void 0, void 0, function* () {
        yield marketLogic.createDemand('Saxonia', Date.now(), Date.now() + 1000, 1000, { privateKey: traderPK });
    }));
    it('should create a supply', () => __awaiter(this, void 0, void 0, function* () {
        yield marketLogic.createSupply([0], 'Saxonia', Date.now(), Date.now() + 1000, 1000, 100, 10, { privateKey: traderPK });
    }));
    it('should create an agreement', () => __awaiter(this, void 0, void 0, function* () {
        yield marketLogic.createAgreement(1, [1], { privateKey: traderPK });
    }));
    dateTimeFrom = Date.now() - 1000;
    dateTimeTo = Date.now();
    it('should log energy', () => __awaiter(this, void 0, void 0, function* () {
        const tx = yield assetRegistry.saveSonnenSmartMeterRead(0, 1000, 'lastSmartMeterReadFileHash', dateTimeFrom, dateTimeTo, 10, 10, 'url', { privateKey: assetSmartmeterPK });
        const event = (yield assetRegistry.getAllLogNewMeterReadEvents({ fromBlock: tx.blockNumber, toBlock: tx.blockNumber }))[0];
        chai_1.assert.equal(event.event, 'LogNewMeterRead');
        chai_1.assert.deepEqual(event.returnValues, {
            0: '0',
            1: '500',
            2: '1000',
            _assetId: '0',
            _oldMeterRead: '500',
            _newMeterRead: '1000',
        });
        const cert = yield (new Certificate.Certificate.Entity('1', conf).sync());
        delete cert.configuration;
        delete cert.proofs;
        chai_1.assert.deepEqual(cert, {
            id: '1',
            initialized: true,
            assetId: '0',
            owner: '0xaf9DdE98b6aeB2225bf87C2cB91c58833fbab2Ab',
            powerInW: '500',
            acceptedToken: '0x0000000000000000000000000000000000000000',
            onCHainDirectPurchasePrice: '0',
            escrow: [],
            approvedAddress: '0x0000000000000000000000000000000000000000',
            activationId: '1',
            dateTimeFrom: '' + dateTimeFrom,
            dateTimeTo: '' + dateTimeTo,
            energyAmount: '500',
            averagePower: '10',
            baselinePower: '10',
            powerProfileURL: 'url',
            powerProfileHash: 'lastSmartMeterReadFileHash',
            reportConfirmed: false,
        });
        console.log(cert);
        /* console.log('\nDemand:');
       console.log(await marketLogic.getDemand(0));
       console.log('\nSupply:');
       console.log(await marketLogic.getSupply(0));
       console.log('\nagreement:');
       console.log(await marketLogic.getAgreement(0));
       */
    }));
});
//# sourceMappingURL=CertificateLogic.js.map