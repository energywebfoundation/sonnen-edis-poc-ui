"use strict";
// Copyright 2018 Energy Web Foundation
// This file is part of the Origin Application brought to you by the Energy Web Foundation,
// a global non-profit organization focused on accelerating blockchain technology across the energy sector,
// incorporated in Zug, Switzerland.
//
// The Origin Application is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
// This is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY and without an implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details, at <http://www.gnu.org/licenses/>.
//
// @authors: slock.it GmbH, Martin Kuechler, martin.kuechler@slock.it
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
const chai_1 = require("chai");
const fs = __importStar(require("fs"));
require("mocha");
const Web3 = require("web3");
const GeneralLib = __importStar(require("ew-utils-general-lib"));
const Logger_1 = require("../Logger");
const ew_user_registry_contracts_1 = require("ew-user-registry-contracts");
const ew_asset_registry_contracts_1 = require("ew-asset-registry-contracts");
const ew_market_contracts_1 = require("ew-market-contracts");
const Market = __importStar(require(".."));
const Asset = __importStar(require("ew-asset-registry-lib"));
describe('Market-Facade', () => {
    const configFile = JSON.parse(fs.readFileSync(process.cwd() + '/connection-config.json', 'utf8'));
    const web3 = new Web3(configFile.develop.web3);
    const privateKeyDeployment = configFile.develop.deployKey.startsWith('0x') ?
        configFile.develop.deployKey : '0x' + configFile.develop.deployKey;
    const accountDeployment = web3.eth.accounts.privateKeyToAccount(privateKeyDeployment).address;
    console.log('acc-deployment: ' + accountDeployment);
    let conf;
    let userLogic;
    let userContractLookup;
    let assetProducingRegistry;
    let marketLogic;
    let userContractLookupAddr;
    let assetContractLookupAddr;
    const assetOwnerPK = '0xfaab95e72c3ac39f7c060125d9eca3558758bb248d1a4cdc9c1b7fd3f91a4485';
    const assetOwnerAddress = web3.eth.accounts.privateKeyToAccount(assetOwnerPK).address;
    const assetSmartmeterPK = '0x2dc5120c26df339dbd9861a0f39a79d87e0638d30fdedc938861beac77bbd3f5';
    const assetSmartmeter = web3.eth.accounts.privateKeyToAccount(assetSmartmeterPK).address;
    const matcherPK = '0xc118b0425221384fe0cbbd093b2a81b1b65d0330810e0792c7059e518cea5383';
    const matcher = web3.eth.accounts.privateKeyToAccount(matcherPK).address;
    const assetSmartmeter2PK = '0x554f3c1470e9f66ed2cf1dc260d2f4de77a816af2883679b1dc68c551e8fa5ed';
    const assetSmartMeter2 = web3.eth.accounts.privateKeyToAccount(assetSmartmeter2PK).address;
    const traderPK = '0x2dc5120c26df339dbd9861a0f39a79d87e0638d30fdedc938861beac77bbd3f5';
    const accountTrader = web3.eth.accounts.privateKeyToAccount(traderPK).address;
    it('should deploy user-registry contracts', () => __awaiter(this, void 0, void 0, function* () {
        const userContracts = yield ew_user_registry_contracts_1.migrateUserRegistryContracts(web3, privateKeyDeployment);
        userContractLookupAddr = userContracts.UserContractLookup;
        userLogic = new ew_user_registry_contracts_1.UserLogic(web3, userContracts.UserLogic);
        yield userLogic.setUser(accountDeployment, 'admin', { privateKey: privateKeyDeployment });
        yield userLogic.setRoles(accountDeployment, 63, { privateKey: privateKeyDeployment });
        yield userLogic.setUser(accountTrader, 'trader', { privateKey: privateKeyDeployment });
        yield userLogic.setRoles(accountTrader, 16, { privateKey: privateKeyDeployment });
        yield userLogic.setUser(assetOwnerAddress, 'assetOwner', { privateKey: privateKeyDeployment });
        yield userLogic.setRoles(assetOwnerAddress, 24, { privateKey: privateKeyDeployment });
    }));
    it('should deploy asset-registry contracts', () => __awaiter(this, void 0, void 0, function* () {
        const deployedContracts = yield ew_asset_registry_contracts_1.migrateAssetRegistryContracts(web3, userContractLookupAddr, privateKeyDeployment);
        assetProducingRegistry = new ew_asset_registry_contracts_1.AssetProducingRegistryLogic(web3, deployedContracts.AssetProducingRegistryLogic);
        assetContractLookupAddr = deployedContracts.AssetContractLookup;
    }));
    it('should deploy market-registry contracts', () => __awaiter(this, void 0, void 0, function* () {
        const deployedContracts = yield ew_market_contracts_1.migrateMarketRegistryContracts(web3, assetContractLookupAddr, privateKeyDeployment);
        marketLogic = new ew_market_contracts_1.MarketLogic(web3, deployedContracts.MarketLogic);
    }));
    describe('Demand-Facade', () => {
        it('should create a demand', () => __awaiter(this, void 0, void 0, function* () {
            conf = {
                blockchainProperties: {
                    activeUser: {
                        address: accountTrader, privateKey: traderPK,
                    },
                    userLogicInstance: userLogic,
                    producingAssetLogicInstance: assetProducingRegistry,
                    marketLogicInstance: marketLogic,
                    web3,
                },
                offChainDataSource: {
                    baseUrl: 'http://localhost:3030',
                },
                logger: Logger_1.logger,
            };
            const demandOffchainProps = {
                timeframe: GeneralLib.TimeFrame.hourly,
                pricePerCertifiedWh: 10,
                currency: GeneralLib.Currency.Ether,
                productingAsset: 0,
                consumingAsset: 0,
                locationCountry: 'string',
                locationRegion: 'string',
                assettype: GeneralLib.AssetType.BiomassGas,
                minCO2Offset: 10,
                otherGreenAttributes: 'string',
                typeOfPublicSupport: 'string',
                targetWhPerPeriod: 10,
                registryCompliance: GeneralLib.Compliance.EEC,
            };
            const demandProps = {
                url: null,
                propertiesDocumentHash: null,
                demandOwner: conf.blockchainProperties.activeUser.address,
            };
            chai_1.assert.equal(yield Market.Demand.getDemandListLength(conf), 0);
            const demand = yield Market.Demand.createDemand(demandProps, demandOffchainProps, conf);
            chai_1.assert.equal(yield Market.Demand.getDemandListLength(conf), 1);
            delete demand.proofs;
            delete demand.configuration;
            delete demand.propertiesDocumentHash;
            chai_1.assert.deepEqual(demand, {
                id: '0',
                initialized: true,
                url: 'http://localhost:3030/Demand',
                demandOwner: accountTrader,
                offChainProperties: {
                    assettype: 3,
                    consumingAsset: 0,
                    currency: 3,
                    locationCountry: 'string',
                    locationRegion: 'string',
                    minCO2Offset: 10,
                    otherGreenAttributes: 'string',
                    pricePerCertifiedWh: 10,
                    productingAsset: 0,
                    registryCompliance: 2,
                    targetWhPerPeriod: 10,
                    timeframe: 3,
                    typeOfPublicSupport: 'string',
                },
            });
        }));
        it('should return demand', () => __awaiter(this, void 0, void 0, function* () {
            const demand = yield (new Market.Demand.Entity('0', conf)).sync();
            delete demand.proofs;
            delete demand.configuration;
            delete demand.propertiesDocumentHash;
            chai_1.assert.deepEqual(demand, {
                id: '0',
                initialized: true,
                url: 'http://localhost:3030/Demand',
                demandOwner: accountTrader,
                offChainProperties: {
                    assettype: 3,
                    consumingAsset: 0,
                    currency: 3,
                    locationCountry: 'string',
                    locationRegion: 'string',
                    minCO2Offset: 10,
                    otherGreenAttributes: 'string',
                    pricePerCertifiedWh: 10,
                    productingAsset: 0,
                    registryCompliance: 2,
                    targetWhPerPeriod: 10,
                    timeframe: 3,
                    typeOfPublicSupport: 'string',
                },
            });
        }));
    });
    describe('Supply-Facade', () => {
        it('should onboard an asset', () => __awaiter(this, void 0, void 0, function* () {
            conf.blockchainProperties.activeUser = {
                address: accountDeployment,
                privateKey: privateKeyDeployment,
            };
            const assetProps = {
                smartMeter: { address: assetSmartmeter },
                owner: { address: assetOwnerAddress },
                lastSmartMeterReadWh: 0,
                active: true,
                lastSmartMeterReadFileHash: 'lastSmartMeterReadFileHash',
                matcher: [{ address: matcher }],
                propertiesDocumentHash: null,
                url: null,
                maxOwnerChanges: 3,
            };
            const assetPropsOffChain = {
                operationalSince: 0,
                capacityWh: 10,
                country: 'USA',
                region: 'AnyState',
                zip: '012345',
                city: 'Anytown',
                street: 'Main-Street',
                houseNumber: '42',
                gpsLatitude: '0.0123123',
                gpsLongitude: '31.1231',
                assetType: Asset.ProducingAsset.Type.Wind,
                complianceRegistry: Asset.ProducingAsset.Compliance.EEC,
                otherGreenAttributes: '',
                typeOfPublicSupport: '',
            };
            chai_1.assert.equal(yield Asset.ProducingAsset.getAssetListLength(conf), 0);
            const asset = yield Asset.ProducingAsset.createAsset(assetProps, assetPropsOffChain, conf);
        }));
        it('should onboard an supply', () => __awaiter(this, void 0, void 0, function* () {
            conf.blockchainProperties.activeUser = {
                address: assetOwnerAddress,
                privateKey: assetOwnerPK,
            };
            const supplyOffChainProperties = {
                price: 10,
                currency: GeneralLib.Currency.USD,
                availableWh: 10,
                timeframe: GeneralLib.TimeFrame.hourly,
            };
            const supplyProps = {
                url: null,
                propertiesDocumentHash: null,
                assetId: 0,
            };
            chai_1.assert.equal(yield Market.Supply.getSupplyListLength(conf), 0);
            const supply = yield Market.Supply.createSupply(supplyProps, supplyOffChainProperties, conf);
            chai_1.assert.equal(yield Market.Supply.getSupplyListLength(conf), 1);
            delete supply.proofs;
            delete supply.configuration;
            delete supply.propertiesDocumentHash;
            chai_1.assert.deepEqual(supply, {
                id: '0',
                initialized: true,
                url: 'http://localhost:3030/Supply',
                assetId: '0',
                offChainProperties: {
                    availableWh: 10,
                    currency: 1,
                    price: 10,
                    timeframe: 3,
                },
            });
        }));
        it('should return supply', () => __awaiter(this, void 0, void 0, function* () {
            const supply = yield (new Market.Supply.Entity('0', conf)).sync();
            delete supply.proofs;
            delete supply.configuration;
            delete supply.propertiesDocumentHash;
            chai_1.assert.deepEqual(supply, {
                id: '0',
                initialized: true,
                url: 'http://localhost:3030/Supply',
                assetId: '0',
                offChainProperties: {
                    availableWh: 10,
                    currency: 1,
                    price: 10,
                    timeframe: 3,
                },
            });
        }));
    });
    describe('Agreement-Facade', () => {
        let startTime;
        it('should create an agreement', () => __awaiter(this, void 0, void 0, function* () {
            conf.blockchainProperties.activeUser = {
                address: accountTrader,
                privateKey: traderPK,
            };
            startTime = Date.now();
            const agreementOffchainProps = {
                start: startTime,
                ende: startTime + 1000,
                price: 10,
                currency: GeneralLib.Currency.USD,
                period: 10,
                timeframe: GeneralLib.TimeFrame.hourly,
            };
            const matcherOffchainProps = {
                currentWh: 0,
                currentPeriod: 0,
            };
            const agreementProps = {
                propertiesDocumentHash: null,
                url: null,
                matcherDBURL: null,
                matcherPropertiesDocumentHash: null,
                demandId: 0,
                supplyId: 0,
                allowedMatcher: [],
            };
            const agreement = yield Market.Agreement.createAgreement(agreementProps, agreementOffchainProps, matcherOffchainProps, conf);
            delete agreement.proofs;
            delete agreement.configuration;
            delete agreement.propertiesDocumentHash;
            delete agreement.matcherPropertiesDocumentHash;
            chai_1.assert.deepEqual(agreement, {
                allowedMatcher: [matcher],
                id: '0',
                initialized: true,
                url: 'http://localhost:3030/Agreement',
                demandId: '0',
                supplyId: '0',
                approvedBySupplyOwner: false,
                approvedByDemandOwner: true,
                matcherDBURL: 'http://localhost:3030/Matcher',
                matcherOffChainProperties: {
                    currentPeriod: 0,
                    currentWh: 0,
                },
                offChainProperties: {
                    currency: 1,
                    ende: startTime + 1000,
                    period: 10,
                    price: 10,
                    start: startTime,
                    timeframe: 3,
                },
            });
        }));
        it('should return an agreement', () => __awaiter(this, void 0, void 0, function* () {
            const agreement = yield (new Market.Agreement.Entity('0', conf)).sync();
            delete agreement.proofs;
            delete agreement.configuration;
            delete agreement.propertiesDocumentHash;
            delete agreement.matcherPropertiesDocumentHash;
            chai_1.assert.deepEqual(agreement, {
                allowedMatcher: [matcher],
                id: '0',
                initialized: true,
                url: 'http://localhost:3030/Agreement',
                demandId: '0',
                supplyId: '0',
                approvedBySupplyOwner: false,
                approvedByDemandOwner: true,
                matcherDBURL: 'http://localhost:3030/Matcher',
                matcherOffChainProperties: {
                    currentPeriod: 0,
                    currentWh: 0,
                },
                offChainProperties: {
                    currency: GeneralLib.Currency.USD,
                    ende: startTime + 1000,
                    period: 10,
                    price: 10,
                    start: startTime,
                    timeframe: 3,
                },
            });
        }));
        it('should agree to an agreement as supply', () => __awaiter(this, void 0, void 0, function* () {
            conf.blockchainProperties.activeUser = {
                address: assetOwnerAddress,
                privateKey: assetOwnerPK,
            };
            let agreement = yield (new Market.Agreement.Entity('0', conf)).sync();
            yield agreement.approveAgreementSupply();
            agreement = yield agreement.sync();
            delete agreement.proofs;
            delete agreement.configuration;
            delete agreement.propertiesDocumentHash;
            delete agreement.matcherPropertiesDocumentHash;
            chai_1.assert.deepEqual(agreement, {
                allowedMatcher: [matcher],
                id: '0',
                initialized: true,
                url: 'http://localhost:3030/Agreement',
                demandId: '0',
                supplyId: '0',
                approvedBySupplyOwner: true,
                approvedByDemandOwner: true,
                matcherDBURL: 'http://localhost:3030/Matcher',
                matcherOffChainProperties: {
                    currentPeriod: 0,
                    currentWh: 0,
                },
                offChainProperties: {
                    currency: 1,
                    ende: startTime + 1000,
                    period: 10,
                    price: 10,
                    start: startTime,
                    timeframe: 3,
                },
            });
        }));
        it('should create a 2nd agreement', () => __awaiter(this, void 0, void 0, function* () {
            conf.blockchainProperties.activeUser = {
                address: assetOwnerAddress,
                privateKey: assetOwnerPK,
            };
            startTime = Date.now();
            const agreementOffchainProps = {
                start: startTime,
                ende: startTime + 1000,
                price: 10,
                currency: GeneralLib.Currency.USD,
                period: 10,
                timeframe: GeneralLib.TimeFrame.hourly,
            };
            const matcherOffchainProps = {
                currentWh: 0,
                currentPeriod: 0,
            };
            const agreementProps = {
                propertiesDocumentHash: null,
                url: null,
                matcherDBURL: null,
                matcherPropertiesDocumentHash: null,
                demandId: 0,
                supplyId: 0,
                allowedMatcher: [],
            };
            const agreement = yield Market.Agreement.createAgreement(agreementProps, agreementOffchainProps, matcherOffchainProps, conf);
            delete agreement.proofs;
            delete agreement.configuration;
            delete agreement.propertiesDocumentHash;
            delete agreement.matcherPropertiesDocumentHash;
            chai_1.assert.deepEqual(agreement, {
                allowedMatcher: [matcher],
                id: '1',
                initialized: true,
                url: 'http://localhost:3030/Agreement',
                demandId: '0',
                supplyId: '0',
                approvedBySupplyOwner: true,
                approvedByDemandOwner: false,
                matcherDBURL: 'http://localhost:3030/Matcher',
                matcherOffChainProperties: {
                    currentPeriod: 0,
                    currentWh: 0,
                },
                offChainProperties: {
                    currency: 1,
                    ende: startTime + 1000,
                    period: 10,
                    price: 10,
                    start: startTime,
                    timeframe: 3,
                },
            });
        }));
        it('should agree to an agreement as demand', () => __awaiter(this, void 0, void 0, function* () {
            conf.blockchainProperties.activeUser = {
                address: accountTrader,
                privateKey: traderPK,
            };
            let agreement = yield (new Market.Agreement.Entity('1', conf)).sync();
            yield agreement.approveAgreementDemand();
            agreement = yield agreement.sync();
            delete agreement.proofs;
            delete agreement.configuration;
            delete agreement.propertiesDocumentHash;
            delete agreement.matcherPropertiesDocumentHash;
            chai_1.assert.deepEqual(agreement, {
                allowedMatcher: [matcher],
                id: '1',
                initialized: true,
                url: 'http://localhost:3030/Agreement',
                demandId: '0',
                supplyId: '0',
                approvedBySupplyOwner: true,
                approvedByDemandOwner: true,
                matcherDBURL: 'http://localhost:3030/Matcher',
                matcherOffChainProperties: {
                    currentPeriod: 0,
                    currentWh: 0,
                },
                offChainProperties: {
                    currency: 1,
                    ende: startTime + 1000,
                    period: 10,
                    price: 10,
                    start: startTime,
                    timeframe: 3,
                },
            });
        }));
        it('should change matcherProperties', () => __awaiter(this, void 0, void 0, function* () {
            conf.blockchainProperties.activeUser = {
                address: matcher,
                privateKey: matcherPK,
            };
            let agreement = yield (new Market.Agreement.Entity('1', conf)).sync();
            const matcherOffchainProps = {
                currentWh: 100,
                currentPeriod: 0,
            };
            yield agreement.setMatcherProperties(matcherOffchainProps);
            agreement = yield agreement.sync();
            delete agreement.proofs;
            delete agreement.configuration;
            delete agreement.propertiesDocumentHash;
            delete agreement.matcherPropertiesDocumentHash;
            chai_1.assert.deepEqual(agreement, {
                allowedMatcher: [matcher],
                id: '1',
                initialized: true,
                url: 'http://localhost:3030/Agreement',
                demandId: '0',
                supplyId: '0',
                approvedBySupplyOwner: true,
                approvedByDemandOwner: true,
                matcherDBURL: 'http://localhost:3030/Matcher',
                matcherOffChainProperties: {
                    currentPeriod: 0,
                    currentWh: 100,
                },
                offChainProperties: {
                    currency: 1,
                    ende: startTime + 1000,
                    period: 10,
                    price: 10,
                    start: startTime,
                    timeframe: 3,
                },
            });
        }));
    });
});
//# sourceMappingURL=MarketFacade.js.map